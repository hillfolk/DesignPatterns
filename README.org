# -*- mode: org; -*-
#+STARTUP: overview
#+STARTUP: content
#+STARTUP: showall
#+STARTUP: showeverything

#+TITLE: Design Patterns and Language-specific Example 

#+Date: 2019-03-15

#+Author: Hillfolk

* Introduction
  디자인 패턴에 대해서 간단하게 소개하고 제가 사용하는 언어별로 구현 해봤습니다. 여러개 언어로 각각 구현했을때 해당 패턴에 대해서 좀더 싶은 이해화 활용 할수 있을것으로 보고 시작하게 되었습니다.
  진행 하다가 분량이 증가할 경우 파일을 나누어 작성하게 될수도 있다. 

* Design Patterns
  디자인 패턴은 GoF 와 POSA 를 많이 참고 하였다. 

* 패턴 사용의 포인트
  - 객체간의 결합을 약화 시켜 유연한 프로그램 작성의 사례를 알려준다.
  - 개발자 간의 의사소통을 돕고 인터페이스 만으로 구현을 짐작하게 할수 있다.
  - 프로그램 설계지 다양한 옵션과 깊이 있는 구조적 고민을 할수 이도록 도와 준다.


** TODO Creational Patterns (생성 패턴)

*** DONE [[./AbstractFactory/AbstractFactory.org][AbstractFactory (추상 팩토리)]]
    구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성 할수 있는 인터페이스를 제공하는 패턴

*** TODO [[./Builder/Builder.org][Builder (빌더)]]
    복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴 

*** TODO Factory Method (팩토리 메서드)
    객체를 생성하는 인터페이스는 미리 정의하되 인스턴스를 만들 클래스의 결정은 서브 클래스 쪽에서 결정하는 패턴입니다. 팩토리 메서드 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브 클래스로 한다. 
    
*** TODO Prototype
    생성할 객체의 종류를 명세하는 데에 원형이 되는 예시물을 시용하고, 그 원형을 복사함으로써 새로운 객체를 생성하는 패턴


*** TODO Singleton
    어떤 클래스의 인스턴스는 오직 하나임을 보장하며 이 인스턴스에 접근할 수 있는 전역적인 접척점을 제공하는 패턴
   

** Structural Pattern (구조 패턴)

*** Adapter (어뎁터 패턴)
    클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변한 하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스 들이 함께 작동하도록 하는 패턴

*** Bridge (브리지 패턴)  
    구현부에서 추상층을 분리하여 각자 독립적으로 변경할 수 있게 하는 패턴

*** Composite (컴포짓 패턴)
    객체들의 관계를 트리구조로 구성하여 부분 전체 계층을 표현하는 패컨으로 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴

*** Decorator (장식자 패턴)
    주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로 기능 확장이 필요할때 서브클래싱 대신 쓸수 있는 유연한 대안이 되는 패턴

*** Facade (파사드 패턴)
    서브 시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로 서브시스템을 좀더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의 하는 패턴

*** Flyweight (플라이급 패턴 )
    크기가 작은 객체가 여러 개 있을 때 공유를 통해서 이들을 효율적으로 지원하는 패턴

*** Proxy (플록시 패턴)
    어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자 또는 자리 채움자를 제공하는 패턴 

** Behavioral Patterns (행동 패턴)
   

*** Chan of Responsibility (책임 연쇄)
    요청을 처리할 수 있는 기회를 하나 이상의 객체에 부여하여 요청을 보내는 객체와 그 요청을 받는 객체 사이에 결합을 피하는 패턴 입니다. 요청을 받을 수 있는 객체를 연쇄적으로 묶고 실제 요청을 처리할 객체를 만날 때까지 객체 고리를 따라서 요청을 전달 하는 패턴

*** Command (커맨드 패턴)
    요청을 객체의 형태로 캡슐화하여 서로 요청이 다른 사용자의 매개변수와 요청 저장 또는 로깅 그리고 연산의 취소를 지원하게 만드는 패턴

*** Interpreter (인터프리터 패턴)
    주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고,이와 아울러 그 표현 수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴

*** TODO [[./Iterator/Iterator.org][Iterator (반복자 패턴)]]
    순차적으로 접근할 수 있는 방법을 제공하는 패턴

*** Mediator (중재자 패턴)
    한 집합에 속해 있는 객체들의 상호작용을 캡슐화하는 객체를 정의하는 패턴, 객체들 간에 서로 참조하지 않도록 함으로써 객체들 사이의 소결합(loose coupling)을 촉진 시키며 개발자가 객체들의 상호작용을 독립적으로 다양화 시킬수 있도록 하는 패턴

*** Memento (메멘토 패턴)
    캡슐화를 위배하지 않는 채로 어떤 객체으 내부 상태를 잡아내고 실체화시켜 이후에 해당 객체가 그 상태로 되돌아 올수 있도록 하는 패턴 

*** Observer (옵저버 패턴)
    객체들 사이에 일대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 객체에 의존성르 가진 다른 객체들의 그 변화를 통지 받고 자동으로 갱신될 수 있게 만드는 패턴

*** DONE [[./State/State.org][State (상태 패턴)]]
    객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴

*** [[./Strategy/Strategy.org][Strategy (전략 패턴)]]
    동일 계열의 알고리즘 군을 정의하고 각각의 알고리즘을 갭슐화하여, 이들을 상호 교환이 가능하도록 만드는 패턴, 알고리즘을 사용하는 객체와 상관없이 독립적으로 변경이 가능하도록 해주는 패턴

*** Template Method (템플릿 메서드 패턴)
    객체의 연산에는 알고리즘의 뼈대만 정의하고 각 단계에서 수행할 구체적 처리는 서브 클래스 쪽으로 미루는 패턴

*** [[./Visitor/Visitor.org][Visitor (방문자 패턴)]]
    객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 해주는 패턴
